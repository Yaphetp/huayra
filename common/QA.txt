1、使用新版本的客户端，提示：某个activity始终无发启动。desiredcaps增加 waitActivity也不行；
2、无法import问题，原因是a,b文件互相引入(循环引入)，导致。
回答：https://www.zhihu.com/question/19887316
3、WebDriverException: Message: A new session could not be created.
 (Original error: Requested a new session but one was in progress
回答：这种情况，就是又特么执行了获取session的方法。
4、定位不到，其实大多数情况下就是两种问题：1 有frame，2 没有加等待。
5、具体函数中使用该变量时，需要事先声明 global variable，否则系统将该变量视为局部变量。
CONSTANT = 0  (将全局变量大写便于识别)
6、jmeter
禹哥 需要先登录的接口怎么测试？登录状态jmeter怎么处理，来一发思路。
赵禹 2017/10/27 11:30:56
可以先跑一下登录的接口，获取登录信息
然后把这些登录信息保存     加入到后续的接口请求中
Yaphet.p 2017/10/27 11:31:33
登录信息 ，通过什么方式加。cookie还是啥
赵禹 2017/10/27 11:32:04
一般是session吧

1\assert False, assertion error;需要的各种assert

2\
logging basicconfig(level = logging.info)
logging.info('n = %d'%n)

3\finally代码快是任何时候都会执行的；通常用于关闭系统的资源

4\自定义异常：
必须继承于Exception类
类名以Error结尾
自定义异常使用raise语句引发，而且只能通过手工引发：

# 发现py文件pycharm [Errno 2] No such file or directory。 右键run一下

#常见异常类型
0、ValueError：Inappropriate argument value (of correct type)
1、NameError： Name not found globally
2、TypeError: Inappropriate argument type
3、AssertionError：Assertion Failed
4、AttributeError：Attribute not found
5、KeyError： mapping key not found
6、IndexError： sequence index out of range

1、判断页面是否出现，比如插屏广告、比如引导页等
1） 可通过判断元素是否能找到
2） 如果是不变的图片，可以通过图片比较

不能通过函数运行状态来确定下一次启动的状态。因为下一次运行时，上次的状态都不会被保留。

调试信息：htmltestrunner 无outputbuffer
appium报错信息：adb version 39 doesn`t match the client 36
原因：前几天安装了andriod studio，sdk的platform-tools下面出现了一个adb.exe；用tool里面的adb.exe代替即可。

AttributeError: '_TestResult' object has no attribute 'outputBuffer',再次出现。
原因：get_driver只能使用一次。忘记注掉后使用used_driver

问：判断手机app的一个提示框中的内容是否正确？
答：Driver提供的方法findElent找到文本框控件，getText就可以做判断了。

dr的使用，之前是get_driver直接放到类里面；后面考虑到会有更多不同的py的class，故不能把get_driver放到某一个类里面，
而应该放到common公用里面。但是 直接import后并未能生效。
可能的原因，import的不正确，from common import appiumDriver    dr=appiumDriver.get_driver()    这样问题目前看起来是解决了。


坐标查看不明确时，使用markman测试长度，来确定元素的位置

andriod 屏幕坐标（显示屏范围：左上角[0,0],右下角[1080,1920]），实际上就是分辨率（象素密度）。

python 除法。如果是两整数相除，只取整数；如果需要准确除法，需要将除数、被除数至少有一个为 a= float(2) 类似


可使用多个属性定位，找出两个属性就可以定位到，或者用 index 下标咯
1、使用find_elements_by_id获取同一个id的所有元素数组，然后通过下标定位

批量约课时，如何判断点击到了可点击的时间点。


随机抽奖
需求&方案：random.randint(start, end)  # 整数 [start, end]之间随机
测试验证（数据量，需要统计出次次随机的某个数的count值）
问题：遇到append之后的list里面的值重复
解决：set（）
衍生问题：set的结果显示set（。。。）
解决：list（set）
完整code：
import random
l = []
for i in range(10):
    d = random.randint(19, 20)
    l.append(d)
ls = set(l)
ll = list(ls)
print llf
for i in ll:
    print i, '   ', l.count(i)
详情请搜索：【random】模块方法说明

需求：
批量约课（根据点击函数范围，分为3列区域，点击获取2节课程；获取成功后，约课（成功判断）；如果没有则更换下一个老师）

需求细分：
1、当前区域，点击n（10）次，每次均要判断是否已经选择两节课；如果未选中
2、当前界面向下，滑动三次（根据函数及界面显示设定），重复上述操作；如果未选中
3、当前节目向下，滑动三次（到达底部），如果未选中

4、当前界面右，滑动3次（中间位置），点击n次，判断是否选中；如果未选中

5、向上滑动，同2、3，方向相反而已

6、重复4，向下滑动，同5方向相反


强行等待：
time.sleep()

显式等待：(10s之内，每0.5s执行一次，直到返回until的函数返回 value is not false)
WebDriverWait每500毫秒调用一次ExpectedCondition，直到有成功的返回，当然如果超过设定的值还没有成功的返回，将抛出异常。
  Example:
            from selenium.webdriver.support.ui import WebDriverWait
            element = WebDriverWait(driver, 10).until(lambda x: x.find_element_by_id("someId")) \n

            is_disappeared = WebDriverWait(driver, 30, 1, (ElementNotVisibleException)).\ \n
                        until_not(lambda x: x.find_element_by_id("someId").is_displayed())

隐式等待：
implicitly_wait()等待，一旦出现就不再等待，否则超时异常。
但是一旦页面上某些js无法加载出来（其实界面元素经出来了），左上角那个图标一直转圈，这时候会一直等待的。
隐性等待对整个driver的周期都起作用，所以只要设置一次即可，不要把隐性等待当成sleep用，走哪儿都来一下

区别：
隐式等待：等到页面全部完成才能执行下一步，我想等我要的元素出来之后就下一步怎么办？
有办法，这就要看selenium提供的另一种等待方式——显性等待wait了。

在其他操作中，隐性等待起决定性作用，
在WebDriverWait..中显性等待起主要作用，但要注意的是：最长的等待时间取决于两者之间的大者，

sleep()： 强制等待，设置固定休眠时间。 python 的 time 包提供了休眠方法 sleep() 导入 time 包后就可以使用 sleep()，进行脚本的执行过程进行休眠。
implicitly_wait()：也叫智能等待，是 webdirver 提供的一个超时等待。等待一个元素被发现，或一个命令完成。如果超出了设置时间的则抛出异常。
WebDriverWait()：显示等待，同样也是 webdirver 提供的方法。在设置时间内，默认每隔一段时间检测一次当前页面元素是否存在，
如果超过设置时间检测不到则抛出异常。默认检测频率为0.5s，默认抛出异常为：NoSuchElementException

class presence_of_element_located(object):
    """ An expectation for checking that an element is present on the DOM
    of a page. This does not necessarily mean that the element is visible.
    locator - used to find the element
    returns the WebElement once it is located
    """
    def __init__(self, locator):
        self.locator = locator
    def __call__(self, driver):
        return _find_element(driver, self.locator)
一个类实例也可以变成一个可调用对象，只需要实现一个特殊方法__call__()。

我们把 Person 类变成一个可调用对象：

class Person(object):
    def __init__(self, name, gender):
        self.name = name
        self.gender = gender

    def __call__(self, friend):
        print 'My name is %s...' % self.name
        print 'My friend is %s...' % friend
现在可以对 Person 实例直接调用：

>>> p = Person('Bob', 'male')
>>> p('Tim')
My name is Bob...
My friend is Tim...
单看 p('Tim') 你无法确定 p 是一个函数还是一个类实例，所以，在Python中，函数也是对象，对象和函数的区别并不显著。


文档字符串，又称为DocStrings。用它可以为我们的模块，类，函数添加说明性的文字，
使程序易读易懂，更重要的是可以通过Python自带的标准方法将这些描述性文字信息输出。下面举例说明。
__doc__()


raise URLError(err)
urllib2.URLError: <urlopen error [Errno 10061] >
解决：
1、可能代理有影响
2、实测，appium没启动起来（第一次启动会有些慢），马上执行了创建session。谁特么的把我的time.sleep删了。。。。。。fuck

UI 自动化测试用例如何设计
1.数据校验，UI截图都要有 ，最好组织成测试报告，以便分析结果。至于UI界面对比这个我没接触过，但有人确实这么做
2.失败后应当截图，也应当记录失败原因
失败原因有两类，脚本有误抛出了异常，另一种是业务功能确实有问题
用例失败了，当然要继续执行下面的，否则自动化就没有效率可言了

继承自unittest.testcase的类方法，只能测试套件方法使用？ 不能当做普通方法调用？
解决：推测每一个测试用例（setup,testcase,teardown）就是一个完整的测试用例，一个测试实例。故不能刻意实例化
除了不可调用测试类的方法外，却刻意调用非测试类的方法。

不同测试类方法可以添加到一个suit里面。


部分text定位，可以通过切片。

Python还支持成员运算符，测试实例中包含了一系列的成员，包括:
字符串
list
元组。
in,  not in, 返回True，False



UnicodeEncodeError: 'ascii' codec can't encode character u'\u6708' in positi
解决：
指定文件字符集为utf-8
在文件头部加入以下代码：
import sys
reload(sys)
sys.setdefaultencoding('utf-8')

  while True in map(
                lambda x: self.dr.find_elements_by_id('com.talk51.dasheng:id/tv_time')[x].text[:6] == '12月05日',
                [0, 1]): # 这里需要注意的是，切片对中文的切割按照个数进行，而不是len（）

问题： 缺少编码类型声明：no encoding declared
解决： 段首添加一行声明即可：#encoding:utf-8

UTF-8是Unicode的实现方式之一，它规定了字符如何在计算机中存储、传输等。

utf-8 没有字节序，所以用来作数据传输和存储很方便。
定长的编码在内存中可以快速访问，所以用来作数据处理时效率高

内码要求处理效率高，外码要求传输方便


